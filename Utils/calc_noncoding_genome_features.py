#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Dec 14 14:31:42 2018

@author: nardus

- Calculate basic genome features on non-coding sequences
- Currently calculates:
    - Nucleotide frequencies
    - GC content
    - AT content
    - Dinucleotide biases
"""

import sys
import pandas
import re
import warnings
from Bio import SeqIO
from collections import Counter



# Column names:
#  (note that dinucleotide names use U instead of T to match the output of CPB_machine.jar)
BASES = ['A', 'T', 'G', 'C', 'N']
DINUCLEOTIDES = ['ApA', 'ApU', 'ApG', 'ApC',
                 'UpA', 'UpU', 'UpG', 'UpC',
                 'GpA', 'GpU', 'GpG', 'GpC',
                 'CpA', 'CpU', 'CpG', 'CpC']

NAMING_PATTERN = r'[.]{4}(.+)_cds_'
NEW_NAME_PATTERN = r'\1'


"""
Calculate nucleotide bias
'baseCounts' should be Counter object
"""
def base_bias(baseCounts):    
    Ntotal = sum(baseCounts.values())
    
    # Using the BASES constant ensures 0s are returned for absent bases:
    bias = {base: baseCounts[base] / Ntotal for base in BASES}
    return bias


"""
Calculate AT and GC bias
'baseCounts' should be Counter object
"""
def content_bias(baseCounts):
    bias = {}
    Ntotal = sum(baseCounts.values())
    
    bias['AT'] = (baseCounts['A'] + baseCounts['T']) / Ntotal
    bias['GC'] = (baseCounts['G'] + baseCounts['C']) / Ntotal
    
    return bias


"""
Create a generator yielding dinucleotides from a string (using a sliding 
window, i.e. all possible dinucleotides)
"""
def generate_dinucleotides(string):
    for i in range(0, len(string)-1):
        yield string[i:i+2]

"""
Calculate dinucleotide bias, as defined in Babayan2018
"""
def dinucleotide_bias(string):
    # Replace all T's with U's (so feature names match those generated by CPB_Machine.jar):
    string = string.replace('T', 'U')
    
    # Count bases and dinucleotides
    dinucs = generate_dinucleotides(string)
    baseCounts = Counter(string)
    dinucleotideCounts = Counter(dinucs)
    
    # Calculate bias
    DNtotal = sum(dinucleotideCounts.values()) # total number of dinucleotides
    Ntotal = len(string)  # total number of bases
    
    biases = {dn: 0 for dn in DINUCLEOTIDES}  # ensure 0 is returned for missing dinucleotides
    
    for dn in dinucleotideCounts.keys():
        base1 = dn[0]
        base2 = dn[1]
        
        if base1 != 'N' and base2 != 'N':
            dinucName = '{0}p{1}'.format(base1, base2)
            
            base1Freq = baseCounts[base1] / Ntotal
            base2Freq = baseCounts[base2] / Ntotal
            
            bias = (dinucleotideCounts[dn] / DNtotal) / (base1Freq * base2Freq)
            biases[dinucName] = bias
    
    return biases
    



"""
Generate genome features for a single virus, which may consist of multiple independent sequences (e.g. genome segments)
'seqs' should be list character strings representing the sequences
"""
def summarise_sequences(name, seqs):
    # Check sequences are valid:
    for i in range(len(seqs)):
        sequence = seqs[i].upper()
    
        # Check for invalid characters:
        invalid = [b for b in sequence if b not in BASES]
    
        if len(invalid) != 0:
            invalid = set(invalid)
            invalidBases = ', '.join(invalid)
            warnings.warn('Sequence contains invalid base(s): {}. These will be replaced with N.'.format(invalidBases), Warning, stacklevel = 2)
            
            for base in invalid:
                sequence = sequence.replace(base, 'N')
                    
        seqs[i] = sequence
    
    # Concatenate sequences
    #   Using a single gap character to separate sequences:
    #    - For dinucleotides, this works because e.g. ATGC-GCAT generates dinucleotides AT, TG, GC, C-, -G, GC, AT; 
    #      here, C- and -G are invalid and will therefore not be counted
    #    - All other features rely on the same basecounts, where we simply remove counts representing
    #      the gap character 
    joined_sequence = '-'.join(seqs)
    
    # Raw base counts:
    rawCounts = Counter(joined_sequence)
    
    # Ensure counts are present for all valid bases (and remove gap character counts):
    baseCounts = {}
    
    for base in BASES:
        if base in rawCounts.keys():
            baseCounts[base] = rawCounts[base]
        else:
            baseCounts[base] = 0
    
    # Features:
    bbias = base_bias(baseCounts)
    cbias = content_bias(baseCounts)
    dnbias = dinucleotide_bias(joined_sequence)
    
    # Remove dinucleotides involving gaps (from concatenation above)
    dnbias = {k: v for k,v in dnbias.items() if not '-' in k}
    
    # Simplify name back to original (matching name parsing done by CPB_Machine.jar):
    name = re.sub(NAMING_PATTERN, NEW_NAME_PATTERN, name)
    
    # Output:
    outDict = {'SeqName': name, 
               **bbias, **cbias, **dnbias}
    
    return outDict



if __name__ == '__main__':
    infile = sys.argv[1]
    outfile = sys.argv[2]
    
    sequences = SeqIO.parse(infile, format = 'fasta')
    
    # Find sequences which have the same name:
    data = {}
    
    for seq_rec in sequences:
        seq_name = seq_rec.description
        seq_string = str(seq_rec.seq)
        
        if seq_name in data.keys():
            data[seq_name].append(seq_string)
        else:
            data[seq_name] = [seq_string]
    
    # Get features for each unique name:
    result = [summarise_sequences(name, seqs) for name, seqs in data.items()]
    
    # Output
    result = pandas.DataFrame(result)
    result.to_csv(outfile, index = False)
    



